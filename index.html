<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scan Visualizer</title>
  <style>
    body { 
      font-family: sans-serif; 
      background:#f5f5f5; 
      padding:10px; 
      margin:0;
      max-width: 100vw;
      overflow-x: hidden;
    }
    
    .container {
      max-width: 100%;
      margin: 0 auto;
    }
    
    h2 {
      text-align: center;
      margin: 10px 0;
    }
    
    .images-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
    }
    
    .image-wrapper {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      min-width: 200px;
      max-width: 300px;
    }
    
    .image-label {
      writing-mode: vertical-rl;
      text-orientation: mixed;
      transform: rotate(180deg);
      font-size: 14px;
      font-weight: bold;
      color: #333;
      white-space: nowrap;
      margin: 0;
      padding: 5px;
    }
    
    .image-content {
      flex: 1;
      text-align: center;
    }
    
    canvas { 
      border: 1px solid #333; 
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto;
    }
    
    .main-controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin: 20px 0;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .slider-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .slider-row label {
      min-width: 120px;
      font-weight: bold;
    }
    
    .slider-row input[type="number"] {
      width: 80px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      order: 1;
    }
    
    .slider-row input[type="range"] {
      flex: 1;
      min-width: 150px;
      order: 2;
    }
    
    /* Resolution slider with discrete ticks */
    .resolution-slider-container {
      position: relative;
      flex: 1;
      min-width: 150px;
      padding: 0 12px; /* Compensate for thumb width (24px/2 = 12px) */
    }
    
    #resolution {
      width: 100%;
      margin-bottom: 20px;
      margin: 0 -12px; /* Counteract container padding for full width */
      width: calc(100% + 24px); /* Extend beyond padding */
    }
    
    .resolution-ticks {
      position: absolute;
      top: 20px;
      left: 12px; /* Align with thumb center */
      right: 12px; /* Align with thumb center */
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #666;
    }
    
    .resolution-ticks .tick {
      position: relative;
      text-align: center;
      width: 0; /* Allow flex to handle spacing */
      display: flex;
      justify-content: center;
      align-items: center;
      transform: translateX(-50%); /* Center the text under the tick mark */
    }
    
    .resolution-ticks .tick::before {
      content: '';
      position: absolute;
      top: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 1px;
      height: 6px;
      background: #666;
    }
    
    .secondary-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin: 20px 0;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .control-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .control-row label {
      min-width: 100px;
      font-weight: bold;
    }
    
    .control-row select {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-width: 120px;
    }
    
    /* Pattern Gallery Styles */
    .pattern-gallery {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 12px;
      margin: 10px 0;
      max-width: 100%;
    }
    
    .pattern-thumbnail {
      position: relative;
      cursor: pointer;
      border: 2px solid #ddd;
      border-radius: 6px;
      overflow: hidden;
      transition: all 0.2s ease;
      background: white;
      aspect-ratio: 1;
    }
    
    .pattern-thumbnail:hover {
      border-color: #007bff;
      transform: scale(1.05);
    }
    
    .pattern-thumbnail.selected {
      border-color: #007bff;
      box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
    }
    
    .pattern-thumbnail canvas {
      width: 100%;
      height: 100%;
      display: block;
      border: none;
      object-fit: cover;
    }
    
    .pattern-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 10px;
      text-align: center;
      padding: 2px;
      font-weight: 500;
    }
    
    .plot-container {
      margin: 20px 0;
      text-align: center;
    }
    
    .plot-container canvas {
      max-width: 100%;
      height: auto;
    }
    
    .plot-legend {
      text-align: center;
      margin: 10px 0;
      font-size: 12px;
      color: #666;
    }
    
    .pattern-section {
      margin: 20px 0;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .pattern-section h3 {
      margin: 0 0 8px 0;
      color: #333;
      font-size: 14px;
    }
    
    .timing-info {
      text-align: center;
      margin: 15px 0;
      font-size: 14px;
      color: #666;
    }
    
    .timing-info span {
      font-weight: 600;
      color: #333;
    }
    
    .limitation-info {
      background: #f0f8ff;
      border: 1px solid #b3d9ff;
      border-radius: 6px;
      padding: 12px;
      margin: 15px 0;
      font-size: 14px;
    }
    
    .limitation-info h3 {
      margin: 0 0 8px 0;
      color: #0066cc;
      font-size: 16px;
    }
    
    @media (max-width: 768px) {
      body {
        padding: 5px;
      }
      
      .images-container {
        flex-direction: column;
        align-items: center;
      }
      
      .image-wrapper {
        max-width: 100%;
        flex-direction: row;
        align-items: center;
      }
      
      .image-label {
        writing-mode: vertical-rl;
        text-orientation: mixed;
        transform: rotate(180deg);
        margin-right: 10px;
        min-width: 20px;
        font-size: 12px;
      }
      
      .main-controls {
        padding: 10px;
        margin: 10px 0;
      }
      
      .slider-row {
        flex-direction: row;
        align-items: center;
        margin-bottom: 8px;
        gap: 8px;
      }
      
      .slider-row .label-input-group {
        display: flex;
        align-items: center;
        gap: 5px;
        min-width: 0;
        flex: 1;
      }
      
      .slider-row label {
        font-size: 12px;
        min-width: auto;
        flex-shrink: 0;
        white-space: nowrap;
      }
      
      .slider-row input[type="number"] {
        width: 50px;
        flex-shrink: 0;
        font-size: 12px;
        padding: 3px 5px;
      }
      
      .slider-row input[type="range"] {
        flex: 1;
        min-width: 80px;
        height: 20px;
      }
      
      .control-row {
        flex-direction: row;
        align-items: center;
        margin-bottom: 8px;
        gap: 8px;
      }
      
      .control-row label {
        min-width: auto;
        font-size: 12px;
        margin-bottom: 0;
      }
      
      .control-row select {
        font-size: 12px;
        padding: 5px;
      }
      
      .pattern-gallery {
        grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
        gap: 6px;
      }
      
      .pattern-thumbnail canvas {
        height: 40px;
      }
      
      .pattern-label {
        font-size: 8px;
        padding: 1px;
      }
      
      .pattern-section {
        padding: 10px;
        margin: 10px 0;
      }
      
      .pattern-section h3 {
        font-size: 12px;
        margin-bottom: 6px;
      }
      
      /* Mobile resolution display styling */
      #resolution-display {
        width: 60px !important;
        font-size: 10px;
        padding: 2px 4px;
      }
      
      .resolution-slider-container {
        min-width: 100px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Pattern Gallery at the very top -->
    <div class="pattern-section">
      <h3>Select Pattern:</h3>
      <div class="pattern-gallery" id="patternGallery">
        <!-- Pattern thumbnails will be generated here -->
      </div>
    </div>
    
    <!-- Images -->
    <div class="images-container">
      <div class="image-wrapper">
        <div class="image-label">Ideal Pattern</div>
        <div class="image-content">
          <canvas id="ideal"></canvas>
        </div>
      </div>
      <div class="image-wrapper">
        <div class="image-label">Simulated Scan</div>
        <div class="image-content">
          <canvas id="sim"></canvas>
        </div>
      </div>
    </div>
    
    <!-- Timing information -->
    <div class="timing-info">
      Line: <span id="lineTime">--</span> | Frame: <span id="frameTime">--</span> | FPS: <span id="fps">--</span>
    </div>
    
    <!-- Main controls for thumb access -->
    <div class="main-controls">
      <div class="slider-group">
        <div class="slider-row">
          <div class="label-input-group">
            <label>Bandwidth (kHz):</label>
            <input id="bw-display" type="number" value="20" step="1">
          </div>
          <input id="bw" type="range" min="0" max="100" value="43" step="1">
        </div>
        <div class="slider-row">
          <div class="label-input-group">
            <label>Dwell time (ns):</label>
            <input id="dwell-display" type="number" value="100" step="10">
          </div>
          <input id="dwell" type="range" min="10" max="1000" value="100" step="10">
        </div>
        <div class="slider-row">
          <div class="label-input-group">
            <label>Line delay (μs):</label>
            <input id="delay-display" type="number" value="0" step="0.1">
          </div>
          <input id="delay" type="range" min="0" max="100000" value="0" step="100">
        </div>
        <div class="slider-row">
          <div class="label-input-group">
            <label>Slew rate (FS/μs):</label>
            <input id="slewRate-display" type="number" value="0.05" step="0.001">
          </div>
          <input id="slewRate" type="range" min="0" max="100" value="57" step="1">
        </div>
      </div>
      
      <!-- Additional controls moved from secondary -->
      <div class="slider-row">
        <div class="label-input-group">
          <label>Resolution:</label>
          <input id="resolution-display" type="text" value="256x256" readonly>
        </div>
        <div class="resolution-slider-container">
          <input id="resolution" type="range" min="0" max="4" value="1" step="1">
          <div class="resolution-ticks">
            <span class="tick">128</span>
            <span class="tick">256</span>
            <span class="tick">512</span>
            <span class="tick">1024</span>
            <span class="tick">2048</span>
          </div>
        </div>
      </div>
      <div class="control-row">
        <label>View:</label>
        <select id="viewMode">
          <option value="normal" selected>Normal</option>
          <option value="error">Displacement Heatmap</option>
          <option value="difference">Difference</option>
        </select>
      </div>
    </div>
    
    <!-- Plot at the top -->
    <div class="plot-container">
      <canvas id="plot" width="500" height="200"></canvas>
      <div class="plot-legend">Red = Digital command; Blue = 1st line; Green = 2nd line; Orange = Last line</div>
    </div>
    
    
    <h2>Scan Visualizer</h2>
    
    <!-- System limitations display -->
    <div class="limitation-info">
      <h3>System Limitations</h3>
      <div id="limitationStatus">No limitations active</div>
    </div>
  </div>

<script>
// Pattern definitions
const patterns = [
  // Image patterns first
  { id: 'image1', name: 'Octo 16:16', type: 'image', src: 'test_images/Octo_1_10kV 2024-07-14_16-16-32.jpeg' },
  { id: 'image2', name: 'Octo 16:20', type: 'image', src: 'test_images/Octo_1_10kV 2024-07-14_16-20-04.jpeg' },
  { id: 'image3', name: 'Eye Edge 2k', type: 'image', src: 'test_images/Edge of the eye no artifacts 2k.jpeg' },
  { id: 'image4', name: 'Pilot 00099', type: 'image', src: 'test_images/2b pilot00099 (1).jpeg' },
  { id: 'image5', name: 'Saved 8bit', type: 'image', src: 'test_images/saved2024-04-06_18-52-04_8bit.jpeg' },
  { id: 'image6', name: 'Messed Up', type: 'image', src: 'test_images/messed it up a bit but ya know.jpeg' },
  // Generated patterns
  { id: 'zone', name: 'Zone Plate' },
  { id: 'checker', name: 'Checkerboard' },
  { id: 'gradx', name: 'Gradient X' },
  { id: 'grady', name: 'Gradient Y' },
  { id: 'ramp2d', name: '2D Ramp' },
  { id: 'slant', name: 'Slanted Edge' },
  { id: 'chirp', name: 'Sine Chirp' },
  { id: 'text', name: 'Text Banner' },
  { id: 'dots', name: 'Random Dots' }
];

let selectedPattern = 'image1';

// Image cache for loaded images
const imageCache = new Map();

// Image data cache for extracted pixel data (CORS-safe)
const imageDataCache = new Map();

// Preload all images on page load and extract pixel data
function preloadImages() {
  const imagePatterns = patterns.filter(p => p.type === 'image');
  
  imagePatterns.forEach(pattern => {
    // Create image directly from source path
    const img = new Image();
    
    img.onload = function() {
      imageCache.set(pattern.src, img);
      console.log(`Preloaded image: ${pattern.name} (${img.width}x${img.height})`);
      
      // Extract pixel data immediately and cache it
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = img.width;
      tempCanvas.height = img.height;
      
      // Draw image to temporary canvas
      tempCtx.drawImage(img, 0, 0);
      
      try {
        // Extract pixel data - this should work for same-origin images
        const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
        imageDataCache.set(pattern.src, {
          data: imageData.data,
          width: img.width,
          height: img.height
        });
        console.log(`Extracted pixel data for: ${pattern.name} (${imageData.data.length} bytes)`);
        
        // Update the thumbnail for this image pattern
        updateImageThumbnail(pattern.id);
        
        // If this is the first image pattern and no pattern is selected yet, select it
        if (pattern.id === 'image1' && selectedPattern === 'image1') {
          // Trigger a re-render now that the image data is loaded
          runSimulation();
        }
      } catch (e) {
        console.error(`Failed to extract pixel data for: ${pattern.name}`, e);
        console.warn(`⚠️  CORS Error: To use image patterns locally, serve this page via HTTP (e.g., 'python3 -m http.server 8000')`);
        console.warn(`   Image patterns will work correctly when deployed to GitHub Pages.`);
      }
    };
    
    img.onerror = function() {
      console.error(`Failed to load image: ${pattern.src}`);
    };
    
    // Load the image directly
    img.src = pattern.src;
  });
}

function drawPattern(ctx, type, w, h) {
  ctx.clearRect(0,0,w,h);
  
  // Handle image patterns
  const pattern = patterns.find(p => p.id === type);
  if (pattern && pattern.type === 'image') {
    drawImagePattern(ctx, type, w, h);
    return;
  }
  
  // Calculate scaling factor based on resolution (256 is baseline)
  const scaleFactor = Math.min(w, h) / 256;
  
  if(type==="checker"){
    let cell = Math.max(4, Math.round(16 * scaleFactor)); // Scale cell size, minimum 4px
    for(let y=0;y<h;y+=cell)
      for(let x=0;x<w;x+=cell){
        ctx.fillStyle=((x/cell+y/cell)%2)?"#000":"#fff";
        ctx.fillRect(x,y,cell,cell);
      }
  } else if(type==="gradx"){
    let g=ctx.createLinearGradient(0,0,w,0);
    g.addColorStop(0,"black"); g.addColorStop(1,"white");
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  } else if(type==="grady"){
    let g=ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,"black"); g.addColorStop(1,"white");
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  } else if(type==="ramp2d"){
    let img=ctx.createImageData(w,h),d=img.data;
    for(let y=0;y<h;y++)for(let x=0;x<w;x++){
      let val=Math.floor(((x/w)+(y/h))/2*255);
      let i=(y*w+x)*4; d[i]=d[i+1]=d[i+2]=val; d[i+3]=255;
    }
    ctx.putImageData(img,0,0);
  } else if(type==="slant"){
    ctx.fillStyle="black"; ctx.fillRect(0,0,w,h);
    ctx.strokeStyle="white"; ctx.lineWidth=Math.max(2, Math.round(4 * scaleFactor));
    ctx.beginPath(); ctx.moveTo(0,h*0.8); ctx.lineTo(w,h*0.2); ctx.stroke();
  } else if(type==="chirp"){
    let img=ctx.createImageData(w,h),d=img.data;
    for(let y=0;y<h;y++)for(let x=0;x<w;x++){
      let freq=0.5+5*(x/w);
      let val=0.5+0.5*Math.sin(2*Math.PI*freq*y/h*20*scaleFactor);
      let g=Math.floor(val*255);
      let i=(y*w+x)*4; d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    ctx.putImageData(img,0,0);
  } else if(type==="zone"){
    let img=ctx.createImageData(w,h),d=img.data;
    for(let y=0;y<h;y++)for(let x=0;x<w;x++){
      let dx=x-w/2, dy=y-h/2;
      let r=Math.sqrt(dx*dx+dy*dy);
      let val=0.5+0.5*Math.sin(r*r/(200*scaleFactor*scaleFactor));
      let g=Math.floor(val*255);
      let i=(y*w+x)*4; d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    ctx.putImageData(img,0,0);
  } else if(type==="text"){
    ctx.fillStyle="black"; ctx.fillRect(0,0,w,h);
    ctx.fillStyle="white"; 
    ctx.font=Math.max(12, Math.round(30 * scaleFactor)) + "px sans-serif";
    ctx.fillText("RESCAN TEST →", Math.round(20 * scaleFactor), h/2);
  } else if(type==="dots"){
    ctx.fillStyle="white"; ctx.fillRect(0,0,w,h);
    let numDots = Math.round(2000 * scaleFactor * scaleFactor);
    for(let i=0;i<numDots;i++){
      ctx.fillStyle=Math.random()<0.5?"black":"gray";
      ctx.fillRect(Math.random()*w,Math.random()*h,1,1);
    }
  }
}

function drawImagePattern(ctx, type, w, h) {
  // Find the pattern definition to get the image source
  const pattern = patterns.find(p => p.id === type);
  if (!pattern || !pattern.src) {
    drawImagePlaceholder(ctx, w, h, 'Image not found');
    return;
  }
  
  // Check if pixel data is cached (this is CORS-safe)
  if (imageDataCache.has(pattern.src)) {
    const cachedData = imageDataCache.get(pattern.src);
    drawImageFromPixelData(ctx, cachedData, w, h);
  } else {
    // Show loading placeholder if not yet loaded
    drawImagePlaceholder(ctx, w, h, 'Loading image...');
  }
}

// Draw image from cached pixel data (CORS-safe, works like generated patterns)
function drawImageFromPixelData(ctx, cachedData, targetWidth, targetHeight) {
  ctx.clearRect(0, 0, targetWidth, targetHeight);
  
  const srcWidth = cachedData.width;
  const srcHeight = cachedData.height;
  const srcData = cachedData.data;
  
  // Calculate aspect ratio and target dimensions
  const aspectRatio = srcHeight / srcWidth;
  const scaledHeight = Math.round(targetWidth * aspectRatio);
  
  // Create target image data
  const targetImageData = ctx.createImageData(targetWidth, targetHeight);
  const targetData = targetImageData.data;
  
  // Scale and copy pixel data
  for (let y = 0; y < scaledHeight; y++) {
    for (let x = 0; x < targetWidth; x++) {
      // Map target pixel to source pixel
      const srcX = Math.floor((x / targetWidth) * srcWidth);
      const srcY = Math.floor((y / scaledHeight) * srcHeight);
      
      const srcIndex = (srcY * srcWidth + srcX) * 4;
      const targetIndex = (y * targetWidth + x) * 4;
      
      // Copy RGBA values
      targetData[targetIndex] = srcData[srcIndex];         // R
      targetData[targetIndex + 1] = srcData[srcIndex + 1]; // G
      targetData[targetIndex + 2] = srcData[srcIndex + 2]; // B
      targetData[targetIndex + 3] = 255;                    // A
    }
  }
  
  // Fill remaining space with black
  for (let y = scaledHeight; y < targetHeight; y++) {
    for (let x = 0; x < targetWidth; x++) {
      const targetIndex = (y * targetWidth + x) * 4;
      targetData[targetIndex] = 0;     // R
      targetData[targetIndex + 1] = 0; // G
      targetData[targetIndex + 2] = 0; // B
      targetData[targetIndex + 3] = 255; // A
    }
  }
  
  // Put the pixel data to the canvas
  ctx.putImageData(targetImageData, 0, 0);
}

function drawScaledImage(ctx, img, w, h) {
  // Clear the canvas first
  ctx.clearRect(0, 0, w, h);
  
  // Calculate aspect ratio preserving dimensions
  // Horizontal = w (resolution), vertical = scaled to maintain aspect ratio
  const aspectRatio = img.height / img.width;
  const targetHeight = Math.round(w * aspectRatio);
  
  // Draw the image scaled to fit the width, maintaining aspect ratio
  ctx.drawImage(img, 0, 0, w, targetHeight);
  
  // Fill any remaining space at the bottom with black
  if (targetHeight < h) {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, targetHeight, w, h - targetHeight);
  }
}

// Convert image to data URL to avoid CORS issues
function convertImageToDataURL(img) {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  
  // Set canvas to image dimensions
  tempCanvas.width = img.width;
  tempCanvas.height = img.height;
  
  // Draw the image
  tempCtx.drawImage(img, 0, 0);
  
  // Convert to data URL
  return tempCanvas.toDataURL('image/png');
}

// Extract image data from the actual image (CORS-safe approach)
function extractImageData(img, targetWidth, targetHeight) {
  console.log(`Extracting real image data: ${targetWidth}x${targetHeight}`);
  
  // Create a temporary canvas to extract the real image data
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  
  tempCanvas.width = targetWidth;
  tempCanvas.height = targetHeight;
  
  // Calculate aspect ratio and draw the real image
  const aspectRatio = img.height / img.width;
  const scaledHeight = Math.round(targetWidth * aspectRatio);
  
  // Draw the actual image
  tempCtx.drawImage(img, 0, 0, targetWidth, scaledHeight);
  
  // Fill remaining space with black if needed
  if (scaledHeight < targetHeight) {
    tempCtx.fillStyle = 'black';
    tempCtx.fillRect(0, scaledHeight, targetWidth, targetHeight - scaledHeight);
  }
  
  // Extract the real image data
  const imageData = tempCtx.getImageData(0, 0, targetWidth, targetHeight).data;
  console.log(`Successfully extracted real image data: ${imageData.length} pixels`);
  return imageData;
}

function drawImagePlaceholder(ctx, w, h, message) {
  ctx.fillStyle = '#f0f0f0';
  ctx.fillRect(0, 0, w, h);
  ctx.fillStyle = '#666';
  ctx.font = '16px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(message, w/2, h/2);
}

function simulate(srcCtx, simCtx, dwellNs, delayNs, bwkHz, slewRateUs){
  const w=srcCtx.canvas.width, h=srcCtx.canvas.height;
  
  // Get image data from the source canvas
  const src = srcCtx.getImageData(0,0,w,h).data;
  
  let dst=simCtx.createImageData(w,h), d=dst.data;
  
  // Calculate time constants
  let tau = 1/(2*Math.PI*bwkHz*1000);
  let maxSlewRate = slewRateUs > 0 ? slewRateUs * 1e6 : Infinity; // FS/s (full-scale per second)
  
  function step(xOut, xCmd, dt) {
    // First apply bandwidth limitation
    let bwLimited = xOut + (xCmd - xOut) * (1 - Math.exp(-dt/tau));
    
    // Then apply slew rate limitation
    if (slewRateUs > 0) {
      let maxChange = maxSlewRate * dt;
      let desiredChange = bwLimited - xOut;
      let actualChange = Math.sign(desiredChange) * Math.min(Math.abs(desiredChange), maxChange);
      return xOut + actualChange;
    }
    
    return bwLimited;
  }
  
  let xOut=0; let recs=[[],[],[],[]]; // digital, line1, line2, last
  for(let j=0;j<h;j++){
    for(let i=0;i<w;i++){
      let xCmd=i/(w-1);
      xOut=step(xOut,xCmd,dwellNs*1e-9);
      let srcX=Math.floor(xOut*w), srcY=j;
      let di=(j*w+i)*4;
      if(srcX>=0&&srcX<w){let si=(srcY*w+srcX)*4; d[di]=src[si]; d[di+1]=src[si+1]; d[di+2]=src[si+2]; d[di+3]=255;}
      else{d[di]=d[di+1]=d[di+2]=0; d[di+3]=255;}
      if(j===0){recs[0].push(xCmd);recs[1].push(xOut);}
      if(j===1)recs[2].push(xOut);
      if(j===h-1)recs[3].push(xOut);
    }
    // flyback
    xOut=step(xOut,0,delayNs*1e-9);
  }
  simCtx.putImageData(dst,0,0);
  return recs;
}

function plot(canvas,recs){
  const ctx=canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const n=recs[0].length;
  function scaleX(i){return 40+i/(n-1)*(canvas.width-50);}
  function scaleY(val){return (canvas.height-20)-val*(canvas.height-40);}
  ctx.strokeStyle="red";ctx.beginPath();
  for(let i=0;i<n;i++){let x=scaleX(i),y=scaleY(Math.min(1,recs[0][i]));if(i==0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}ctx.stroke();
  let colors=["blue","green","orange"];
  for(let k=1;k<=3;k++){ctx.strokeStyle=colors[k-1];ctx.beginPath();
    for(let i=0;i<n;i++){let x=scaleX(i),y=scaleY(Math.min(1,recs[k][i]));if(i==0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}ctx.stroke();}
}

// Convert slider position to exponential slew rate value
function sliderToSlewRate(sliderValue) {
  // Map slider (0-100) to exponential range (0.001 to 1.0)
  // Using exponential: 0.001 * (1000 ^ (sliderValue/100))
  const minSlew = 0.001;
  const maxSlew = 1.0;
  const ratio = maxSlew / minSlew;
  return minSlew * Math.pow(ratio, sliderValue / 100);
}

// Convert slew rate value to slider position
function slewRateToSlider(slewRateValue) {
  const minSlew = 0.001;
  const maxSlew = 1.0;
  const ratio = maxSlew / minSlew;
  return 100 * (Math.log(slewRateValue / minSlew) / Math.log(ratio));
}

// Convert slider position to exponential bandwidth value
function sliderToBandwidth(sliderValue) {
  // Map slider (0-100) to exponential range (1 to 1000 kHz)
  // Using exponential: 1 * (1000 ^ (sliderValue/100))
  const minBw = 1;
  const maxBw = 1000;
  const ratio = maxBw / minBw;
  return minBw * Math.pow(ratio, sliderValue / 100);
}

// Convert bandwidth value to slider position
function bandwidthToSlider(bandwidthValue) {
  const minBw = 1;
  const maxBw = 1000;
  const ratio = maxBw / minBw;
  return 100 * (Math.log(bandwidthValue / minBw) / Math.log(ratio));
}

function calculateTiming(dwellNs, delayNs, resolution) {
  // Calculate line time: (pixels per line * dwell time) + line delay
  const lineTimeNs = (resolution * dwellNs) + delayNs;
  const lineTimeMs = lineTimeNs / 1e6; // Convert to milliseconds
  
  // Calculate frame time: line time * number of lines
  const frameTimeNs = lineTimeNs * resolution;
  const frameTimeMs = frameTimeNs / 1e6; // Convert to milliseconds
  
  // Calculate frames per second
  const fps = 1000 / frameTimeMs; // Convert ms to seconds and invert
  
  return {
    lineTimeNs: lineTimeNs,
    lineTimeMs: lineTimeMs,
    frameTimeNs: frameTimeNs,
    frameTimeMs: frameTimeMs,
    fps: fps
  };
}

function updateTimingDisplay(timing) {
  document.getElementById('lineTime').textContent = `${timing.lineTimeMs.toFixed(3)} ms`;
  document.getElementById('frameTime').textContent = `${timing.frameTimeMs.toFixed(3)} ms`;
  document.getElementById('fps').textContent = `${timing.fps.toFixed(2)} fps`;
}

function calculateDisplacement(dwellNs, delayNs, bwkHz, slewRateUs, w, h) {
  let tau = 1/(2*Math.PI*bwkHz*1000);
  let maxSlewRate = slewRateUs > 0 ? slewRateUs * 1e6 : Infinity; // FS/s (full-scale per second)
  
  function step(xOut, xCmd, dt) {
    // First apply bandwidth limitation
    let bwLimited = xOut + (xCmd - xOut) * (1 - Math.exp(-dt/tau));
    
    // Then apply slew rate limitation
    if (slewRateUs > 0) {
      let maxChange = maxSlewRate * dt;
      let desiredChange = bwLimited - xOut;
      let actualChange = Math.sign(desiredChange) * Math.min(Math.abs(desiredChange), maxChange);
      return xOut + actualChange;
    }
    
    return bwLimited;
  }
  
  let displacements = [];
  let xOut = 0;
  
  for(let j = 0; j < h; j++) {
    for(let i = 0; i < w; i++) {
      let xCmd = i / (w - 1);
      xOut = step(xOut, xCmd, dwellNs * 1e-9);
      let displacement = Math.abs(xOut - xCmd);
      displacements.push(displacement);
    }
    // flyback
    xOut = step(xOut, 0, delayNs * 1e-9);
  }
  
  return displacements;
}

function drawDisplacementHeatmap(ctx, displacements, w, h) {
  ctx.clearRect(0,0,w,h);
  let img = ctx.createImageData(w,h);
  let d = img.data;
  
  let maxDisplacement = Math.max(...displacements);
  
  for(let y=0; y<h; y++) {
    for(let x=0; x<w; x++) {
      let i = (y*w+x)*4;
      let displacement = displacements[y*w+x];
      let intensity = displacement / maxDisplacement;
      
      // Color mapping: blue (low displacement) to red (high displacement)
      if(intensity < 0.5) {
        d[i] = 0; // R
        d[i+1] = Math.floor(255 * intensity * 2); // G
        d[i+2] = 255; // B
      } else {
        d[i] = Math.floor(255 * (intensity - 0.5) * 2); // R
        d[i+1] = Math.floor(255 * (1 - intensity) * 2); // G
        d[i+2] = 0; // B
      }
      d[i+3] = 255; // A
    }
  }
  
  ctx.putImageData(img,0,0);
}

function drawDifference(idealCtx, simCtx, w, h) {
  const ideal = idealCtx.getImageData(0,0,w,h).data;
  const sim = simCtx.getImageData(0,0,w,h).data;
  
  let img = simCtx.createImageData(w,h);
  let d = img.data;
  
  for(let y=0; y<h; y++) {
    for(let x=0; x<w; x++) {
      let i = (y*w+x)*4;
      let idealGray = (ideal[i] + ideal[i+1] + ideal[i+2]) / 3;
      let simGray = (sim[i] + sim[i+1] + sim[i+2]) / 3;
      let diff = Math.abs(idealGray - simGray);
      
      // Show difference as grayscale
      d[i] = d[i+1] = d[i+2] = diff;
      d[i+3] = 255;
    }
  }
  
  simCtx.putImageData(img,0,0);
}

function updateLimitationStatus(dwellNs, bwkHz, slewRateUs) {
  const statusEl = document.getElementById('limitationStatus');
  let limitations = [];
  
  // Calculate bandwidth limitation
  const bwFreq = 1 / (2 * Math.PI * bwkHz * 1000);
  const bwTimeConstant = bwFreq;
  
  // Calculate slew rate limitation
  let slewRateText = '';
  if (slewRateUs > 0) {
    const maxSlewRate = slewRateUs * 1e6; // FS/s (full-scale per second)
    const maxChangePerDwell = maxSlewRate * dwellNs * 1e-9;
    slewRateText = `Slew rate: ${slewRateUs} FS/μs (max change per dwell: ${(maxChangePerDwell * 100).toFixed(2)}%)`;
    limitations.push(slewRateText);
  }
  
  // Bandwidth limitation
  const bwText = `Bandwidth: ${bwkHz} kHz (τ = ${(bwTimeConstant * 1e9).toFixed(1)} ns)`;
  limitations.push(bwText);
  
  if (limitations.length === 0) {
    statusEl.textContent = 'No limitations active';
  } else {
    statusEl.innerHTML = limitations.join('<br>');
  }
}

function runSimulation() {
  const dwell=+document.getElementById("dwell-display").value;
  const delay=+document.getElementById("delay-display").value * 1000; // Convert μs to ns
  const bw=+document.getElementById("bw-display").value;
  const slewRate=+document.getElementById("slewRate-display").value;
  const pat=selectedPattern;
  const resolutionValues = [128, 256, 512, 1024, 2048];
  const resolutionSliderValue = parseInt(document.getElementById("resolution").value);
  const resolution = resolutionValues[resolutionSliderValue];
  
  const idealCanvas=document.getElementById("ideal");
  const simCanvas=document.getElementById("sim");
  
  // Set canvas dimensions based on pattern type
  const pattern = patterns.find(p => p.id === pat);
  if (pattern && pattern.type === 'image') {
    // For images, preserve aspect ratio
    if (imageCache.has(pattern.src)) {
      const img = imageCache.get(pattern.src);
      const aspectRatio = img.height / img.width;
      const canvasHeight = Math.round(resolution * aspectRatio);
      
      idealCanvas.width = resolution;
      idealCanvas.height = canvasHeight;
      simCanvas.width = resolution;
      simCanvas.height = canvasHeight;
    } else {
      // Fallback to square if image not loaded
      idealCanvas.width = resolution;
      idealCanvas.height = resolution;
      simCanvas.width = resolution;
      simCanvas.height = resolution;
    }
  } else {
    // For all other patterns, use square resolution
    idealCanvas.width = resolution;
    idealCanvas.height = resolution;
    simCanvas.width = resolution;
    simCanvas.height = resolution;
  }
  
  // Set display size to be constant to prevent UI jumping
  const displaySize = 300; // Fixed display size regardless of resolution
  
  if (pattern && pattern.type === 'image') {
    // For images, maintain aspect ratio in display
    const aspectRatio = idealCanvas.height / idealCanvas.width;
    const displayHeight = Math.round(displaySize * aspectRatio);
    
    idealCanvas.style.width = displaySize + 'px';
    idealCanvas.style.height = displayHeight + 'px';
    simCanvas.style.width = displaySize + 'px';
    simCanvas.style.height = displayHeight + 'px';
  } else {
    // For square patterns, use square display
    idealCanvas.style.width = displaySize + 'px';
    idealCanvas.style.height = displaySize + 'px';
    simCanvas.style.width = displaySize + 'px';
    simCanvas.style.height = displaySize + 'px';
  }
  
  const ideal=idealCanvas.getContext("2d");
  const sim=simCanvas.getContext("2d");
  drawPattern(ideal,pat,idealCanvas.width,idealCanvas.height);
  console.log(`Running simulation for pattern: ${pat}, resolution: ${idealCanvas.width}x${idealCanvas.height}`);
  
  // All patterns use the same simulation approach
  const recs=simulate(ideal,sim,dwell,delay,bw,slewRate);
  plot(document.getElementById("plot"),recs);
  
  // Calculate and display timing information
  const timing = calculateTiming(dwell, delay, idealCanvas.width);
  updateTimingDisplay(timing);
  
  // Update limitation status
  updateLimitationStatus(dwell, bw, slewRate);
  
  // Apply view mode
  const viewMode = document.getElementById("viewMode").value;
  if (viewMode === "error") {
    const displacements = calculateDisplacement(dwell, delay, bw, slewRate, resolution, resolution);
    drawDisplacementHeatmap(sim, displacements, resolution, resolution);
  } else if (viewMode === "difference") {
    drawDifference(ideal, sim, resolution, resolution);
  }
}

// Update display values when sliders change
function updateDisplayValues() {
  document.getElementById("bw-display").value = Math.round(sliderToBandwidth(+document.getElementById("bw").value));
  document.getElementById("dwell-display").value = document.getElementById("dwell").value;
  document.getElementById("delay-display").value = (+document.getElementById("delay").value / 1000).toFixed(1); // Convert ns to μs
  document.getElementById("slewRate-display").value = sliderToSlewRate(+document.getElementById("slewRate").value).toFixed(3);
}

function updateResolutionDisplay() {
  const resolutionValues = [128, 256, 512, 1024, 2048];
  const sliderValue = parseInt(document.getElementById("resolution").value);
  const resolution = resolutionValues[sliderValue];
  document.getElementById("resolution-display").value = `${resolution}x${resolution}`;
}

// Update sliders when number inputs change
function updateSliderFromInput(sliderId, inputId, isSlewRate = false) {
  const inputValue = parseFloat(document.getElementById(inputId).value);
  const slider = document.getElementById(sliderId);
  
  if (isSlewRate) {
    // For slew rate, convert input value to slider position
    const sliderPos = slewRateToSlider(inputValue);
    const clampedPos = Math.max(0, Math.min(100, sliderPos));
    slider.value = clampedPos;
  } else if (sliderId === "bw") {
    // For bandwidth, convert input value to slider position using exponential scaling
    const sliderPos = bandwidthToSlider(inputValue);
    const clampedPos = Math.max(0, Math.min(100, sliderPos));
    slider.value = clampedPos;
  } else if (sliderId === "delay") {
    // For delay, convert from μs to ns for slider comparison
    const delayNs = inputValue * 1000;
    const min = parseFloat(slider.min);
    const max = parseFloat(slider.max);
    if (delayNs >= min && delayNs <= max) {
      slider.value = delayNs;
    }
    // If out of range, don't update slider but still allow the value
  } else {
    // For other controls, only update slider if value is within range
    const min = parseFloat(slider.min);
    const max = parseFloat(slider.max);
    if (inputValue >= min && inputValue <= max) {
      slider.value = inputValue;
    }
    // If out of range, don't update slider but still allow the value
  }
}

// Pattern Gallery Functions
function updateImageThumbnail(patternId) {
  const thumbnail = document.querySelector(`[data-pattern="${patternId}"]`);
  if (!thumbnail) return;
  
  const canvas = thumbnail.querySelector('canvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  drawPattern(ctx, patternId, 80, 80);
}

function createPatternThumbnail(pattern) {
  const thumbnail = document.createElement('div');
  thumbnail.className = 'pattern-thumbnail';
  thumbnail.dataset.pattern = pattern.id;
  
  const canvas = document.createElement('canvas');
  canvas.width = 80;
  canvas.height = 80;
  
  const ctx = canvas.getContext('2d');
  drawPattern(ctx, pattern.id, 80, 80);
  
  const label = document.createElement('div');
  label.className = 'pattern-label';
  label.textContent = pattern.name;
  
  thumbnail.appendChild(canvas);
  thumbnail.appendChild(label);
  
  thumbnail.addEventListener('click', () => {
    selectPattern(pattern.id);
  });
  
  return thumbnail;
}

function selectPattern(patternId) {
  selectedPattern = patternId;
  
  // Update visual selection
  document.querySelectorAll('.pattern-thumbnail').forEach(thumb => {
    thumb.classList.remove('selected');
  });
  
  document.querySelector(`[data-pattern="${patternId}"]`).classList.add('selected');
  
  // Run simulation with new pattern
  runSimulation();
}

function initializePatternGallery() {
  const gallery = document.getElementById('patternGallery');
  gallery.innerHTML = '';
  
  patterns.forEach(pattern => {
    const thumbnail = createPatternThumbnail(pattern);
    gallery.appendChild(thumbnail);
  });
  
  // Select default pattern
  selectPattern('image1');
}

// Auto-simulation on any parameter change
document.getElementById("dwell").oninput = function() {
  updateDisplayValues();
  runSimulation();
};
document.getElementById("delay").oninput = function() {
  updateDisplayValues();
  runSimulation();
};
document.getElementById("bw").oninput = function() {
  updateDisplayValues();
  runSimulation();
};
document.getElementById("slewRate").oninput = function() {
  updateDisplayValues();
  runSimulation();
};

document.getElementById("resolution").oninput = function() {
  updateResolutionDisplay();
  runSimulation();
};

// Handle number input changes
document.getElementById("bw-display").oninput = function() {
  updateSliderFromInput("bw", "bw-display");
  runSimulation();
};
document.getElementById("dwell-display").oninput = function() {
  updateSliderFromInput("dwell", "dwell-display");
  runSimulation();
};
document.getElementById("delay-display").oninput = function() {
  updateSliderFromInput("delay", "delay-display");
  runSimulation();
};
document.getElementById("slewRate-display").oninput = function() {
  updateSliderFromInput("slewRate", "slewRate-display", true);
  runSimulation();
};

document.getElementById("viewMode").onchange = runSimulation;

// Initialize pattern gallery and run simulation
preloadImages(); // Preload all images
initializePatternGallery();
updateDisplayValues();
updateResolutionDisplay();
runSimulation(); // Initial run with default values

// Slider validation tests (run in console for debugging)
function runSliderTests() {
  console.log('🧪 Running Slider Validation Tests...\n');
  
  // Test bandwidth default
  const bwSlider = document.getElementById("bw").value;
  const bwDisplay = document.getElementById("bw-display").value;
  const bwCalculated = Math.round(sliderToBandwidth(+bwSlider));
  console.log(`Bandwidth: Slider ${bwSlider} → Display ${bwDisplay} → Calculated ${bwCalculated} kHz`);
  
  // Test slew rate default
  const slewSlider = document.getElementById("slewRate").value;
  const slewDisplay = document.getElementById("slewRate-display").value;
  const slewCalculated = sliderToSlewRate(+slewSlider).toFixed(3);
  console.log(`Slew Rate: Slider ${slewSlider} → Display ${slewDisplay} → Calculated ${slewCalculated} FS/μs`);
  
  // Test bidirectional conversion
  const testBw = 20;
  const testSlider = bandwidthToSlider(testBw);
  const backToBw = Math.round(sliderToBandwidth(testSlider));
  console.log(`Bidirectional: ${testBw} kHz → slider ${testSlider.toFixed(1)} → ${backToBw} kHz`);
  
  // Validate defaults
  const bwCorrect = bwCalculated == 20;
  const slewCorrect = Math.abs(parseFloat(slewCalculated) - 0.05) < 0.01;
  
  console.log(`\n📊 Validation Results:`);
  console.log(`Bandwidth default correct: ${bwCorrect ? '✅' : '❌'}`);
  console.log(`Slew rate default correct: ${slewCorrect ? '✅' : '❌'}`);
  console.log(`All tests passed: ${bwCorrect && slewCorrect ? '✅' : '❌'}`);
  
  return bwCorrect && slewCorrect;
}

// Uncomment the line below to run tests automatically
// runSliderTests();
</script>
</body>
</html>