<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scan Visualizer</title>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
      background: #fafafa; 
      padding: 20px; 
      margin: 0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
    }
    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }
    label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }
    input, select {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
    }
    input[type="range"] {
      width: 120px;
      margin: 0 8px;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }
    .slider-value {
      min-width: 60px;
      text-align: right;
      font-weight: 500;
    }
    .slider-input {
      width: 80px;
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .visualization {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .canvas-container {
      flex: 1;
      min-width: 300px;
      text-align: center;
    }
    .canvas-label {
      font-size: 14px;
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
      text-align: center;
    }
    canvas {
      border: 1px solid #ddd;
      border-radius: 8px;
      display: block;
      margin: 0 auto;
    }
    .error-info {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
    }
    .error-heatmap {
      position: relative;
    }
    .error-heatmap canvas {
      cursor: crosshair;
    }
    .plot-container {
      text-align: center;
    }
    .plot-label {
      font-size: 12px;
      color: #666;
      margin-top: 8px;
    }
    .timing-info {
      text-align: center;
      margin-top: 15px;
      font-size: 14px;
      color: #666;
    }
    .timing-info span {
      font-weight: 600;
      color: #333;
    }
    .limitation-info {
      background: #f0f8ff;
      border: 1px solid #b3d9ff;
      border-radius: 6px;
      padding: 12px;
      margin: 15px 0;
      font-size: 14px;
    }
    .limitation-info h3 {
      margin: 0 0 8px 0;
      color: #0066cc;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Scan Visualizer</h1>
    
    <div class="controls">
      <label>Dwell time (ns): <input id="dwell" type="number" value="100"></label>
      <label>Line delay (ns): <input id="delay" type="number" value="0"></label>
      <div class="slider-container">
        <label>Bandwidth (kHz):</label>
        <input id="bw" type="range" min="0" max="100" value="43" step="1">
        <span class="slider-value" id="bwValue">20</span>
        <input id="bwInput" type="number" class="slider-input" value="20" step="1">
      </div>
      <div class="slider-container">
        <label>Slew rate (FS/μs):</label>
        <input id="slewRate" type="range" min="0" max="100" value="57" step="1">
        <span class="slider-value" id="slewRateValue">0.050</span>
        <input id="slewRateInput" type="number" class="slider-input" value="0.05" step="0.001">
      </div>
      <label>Resolution:
        <select id="resolution">
          <option value="128">128x128</option>
          <option value="256" selected>256x256</option>
          <option value="512">512x512</option>
          <option value="1024">1024x1024</option>
        </select>
      </label>
      <label>Pattern:
        <select id="pattern">
          <option value="zone" selected>Zone Plate</option>
          <option value="checker">Checkerboard</option>
          <option value="gradx">Gradient X</option>
          <option value="grady">Gradient Y</option>
          <option value="ramp2d">2D Ramp</option>
          <option value="slant">Slanted Edge</option>
          <option value="chirp">Sine Chirp</option>
          <option value="text">Text Banner</option>
          <option value="dots">Random Dots</option>
        </select>
      </label>
      <label>View:
        <select id="viewMode">
          <option value="normal">Normal</option>
          <option value="error">Displacement Heatmap</option>
          <option value="difference">Difference</option>
        </select>
      </label>
    </div>

    <div class="limitation-info">
      <h3>System Limitations</h3>
      <div id="limitationStatus">No limitations active</div>
    </div>

    <div class="visualization">
      <div class="canvas-container">
        <div class="canvas-label">Ideal Pattern</div>
        <canvas id="ideal"></canvas>
      </div>
      <div class="canvas-container">
        <div class="canvas-label">Simulated Scan</div>
        <canvas id="sim"></canvas>
      </div>
    </div>

    <div class="timing-info">
      Line: <span id="lineTime">--</span> | Frame: <span id="frameTime">--</span> | FPS: <span id="fps">--</span>
    </div>

    <div class="plot-container">
      <canvas id="plot" width="600" height="200"></canvas>
      <div class="plot-label">Red = Digital command; Blue = 1st line; Green = 2nd line; Orange = Last line</div>
    </div>
  </div>

<script>
function drawPattern(ctx, type, w, h) {
  ctx.clearRect(0,0,w,h);
  if(type==="checker"){
    let cell=16;
    for(let y=0;y<h;y+=cell)
      for(let x=0;x<w;x+=cell){
        ctx.fillStyle=((x/cell+y/cell)%2)?"#000":"#fff";
        ctx.fillRect(x,y,cell,cell);
      }
  } else if(type==="gradx"){
    let g=ctx.createLinearGradient(0,0,w,0);
    g.addColorStop(0,"black"); g.addColorStop(1,"white");
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  } else if(type==="grady"){
    let g=ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,"black"); g.addColorStop(1,"white");
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  } else if(type==="ramp2d"){
    let img=ctx.createImageData(w,h),d=img.data;
    for(let y=0;y<h;y++)for(let x=0;x<w;x++){
      let val=Math.floor(((x/w)+(y/h))/2*255);
      let i=(y*w+x)*4; d[i]=d[i+1]=d[i+2]=val; d[i+3]=255;
    }
    ctx.putImageData(img,0,0);
  } else if(type==="slant"){
    ctx.fillStyle="black"; ctx.fillRect(0,0,w,h);
    ctx.strokeStyle="white"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(0,h*0.8); ctx.lineTo(w,h*0.2); ctx.stroke();
  } else if(type==="chirp"){
    let img=ctx.createImageData(w,h),d=img.data;
    for(let y=0;y<h;y++)for(let x=0;x<w;x++){
      let freq=0.5+5*(x/w);
      let val=0.5+0.5*Math.sin(2*Math.PI*freq*y/h*20);
      let g=Math.floor(val*255);
      let i=(y*w+x)*4; d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    ctx.putImageData(img,0,0);
  } else if(type==="zone"){
    let img=ctx.createImageData(w,h),d=img.data;
    for(let y=0;y<h;y++)for(let x=0;x<w;x++){
      let dx=x-w/2, dy=y-h/2;
      let r=Math.sqrt(dx*dx+dy*dy);
      let val=0.5+0.5*Math.sin(r*r/200);
      let g=Math.floor(val*255);
      let i=(y*w+x)*4; d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    ctx.putImageData(img,0,0);
  } else if(type==="text"){
    ctx.fillStyle="black"; ctx.fillRect(0,0,w,h);
    ctx.fillStyle="white"; ctx.font="30px sans-serif";
    ctx.fillText("RESCAN TEST →",20,h/2);
  } else if(type==="dots"){
    ctx.fillStyle="white"; ctx.fillRect(0,0,w,h);
    for(let i=0;i<2000;i++){
      ctx.fillStyle=Math.random()<0.5?"black":"gray";
      ctx.fillRect(Math.random()*w,Math.random()*h,1,1);
    }
  }
}

function simulate(srcCtx, simCtx, dwellNs, delayNs, bwkHz, slewRateUs){
  const w=srcCtx.canvas.width, h=srcCtx.canvas.height;
  const src=srcCtx.getImageData(0,0,w,h).data;
  let dst=simCtx.createImageData(w,h), d=dst.data;
  
  // Calculate time constants
  let tau = 1/(2*Math.PI*bwkHz*1000);
  let maxSlewRate = slewRateUs > 0 ? slewRateUs * 1e6 : Infinity; // FS/s (full-scale per second)
  
  function step(xOut, xCmd, dt) {
    // First apply bandwidth limitation
    let bwLimited = xOut + (xCmd - xOut) * (1 - Math.exp(-dt/tau));
    
    // Then apply slew rate limitation
    if (slewRateUs > 0) {
      let maxChange = maxSlewRate * dt;
      let desiredChange = bwLimited - xOut;
      let actualChange = Math.sign(desiredChange) * Math.min(Math.abs(desiredChange), maxChange);
      return xOut + actualChange;
    }
    
    return bwLimited;
  }
  
  let xOut=0; let recs=[[],[],[],[]]; // digital, line1, line2, last
  for(let j=0;j<h;j++){
    for(let i=0;i<w;i++){
      let xCmd=i/(w-1);
      xOut=step(xOut,xCmd,dwellNs*1e-9);
      let srcX=Math.floor(xOut*w), srcY=j;
      let di=(j*w+i)*4;
      if(srcX>=0&&srcX<w){let si=(srcY*w+srcX)*4; d[di]=src[si]; d[di+1]=src[si+1]; d[di+2]=src[si+2]; d[di+3]=255;}
      else{d[di]=d[di+1]=d[di+2]=0; d[di+3]=255;}
      if(j===0){recs[0].push(xCmd);recs[1].push(xOut);}
      if(j===1)recs[2].push(xOut);
      if(j===h-1)recs[3].push(xOut);
    }
    // flyback
    xOut=step(xOut,0,delayNs*1e-9);
  }
  simCtx.putImageData(dst,0,0);
  return recs;
}

function calculateDisplacement(dwellNs, delayNs, bwkHz, slewRateUs, w, h) {
  let tau = 1/(2*Math.PI*bwkHz*1000);
  let maxSlewRate = slewRateUs > 0 ? slewRateUs * 1e6 : Infinity; // FS/s (full-scale per second)
  
  function step(xOut, xCmd, dt) {
    let bwLimited = xOut + (xCmd - xOut) * (1 - Math.exp(-dt/tau));
    if (slewRateUs > 0) {
      let maxChange = maxSlewRate * dt;
      let desiredChange = bwLimited - xOut;
      let actualChange = Math.sign(desiredChange) * Math.min(Math.abs(desiredChange), maxChange);
      return xOut + actualChange;
    }
    return bwLimited;
  }
  
  let displacements = [];
  let xOut = 0;
  
  for(let j = 0; j < h; j++) {
    for(let i = 0; i < w; i++) {
      let xCmd = i / (w - 1);
      xOut = step(xOut, xCmd, dwellNs * 1e-9);
      let displacement = Math.abs(xOut - xCmd);
      displacements.push(displacement);
    }
    // flyback
    xOut = step(xOut, 0, delayNs * 1e-9);
  }
  
  return displacements;
}

function drawDisplacementHeatmap(ctx, displacements, w, h) {
  ctx.clearRect(0,0,w,h);
  let img = ctx.createImageData(w,h);
  let d = img.data;
  
  let maxDisplacement = Math.max(...displacements);
  
  for(let y=0; y<h; y++) {
    for(let x=0; x<w; x++) {
      let i = (y*w+x)*4;
      let displacement = displacements[y*w+x];
      let intensity = displacement / maxDisplacement;
      
      // Color mapping: blue (low displacement) to red (high displacement)
      if(intensity < 0.5) {
        d[i] = 0; // R
        d[i+1] = Math.floor(255 * intensity * 2); // G
        d[i+2] = 255; // B
      } else {
        d[i] = Math.floor(255 * (intensity - 0.5) * 2); // R
        d[i+1] = Math.floor(255 * (1 - intensity) * 2); // G
        d[i+2] = 0; // B
      }
      d[i+3] = 255; // A
    }
  }
  
  ctx.putImageData(img,0,0);
}

function drawDifference(idealCtx, simCtx, w, h) {
  const ideal = idealCtx.getImageData(0,0,w,h).data;
  const sim = simCtx.getImageData(0,0,w,h).data;
  
  let img = simCtx.createImageData(w,h);
  let d = img.data;
  
  for(let y=0; y<h; y++) {
    for(let x=0; x<w; x++) {
      let i = (y*w+x)*4;
      let idealGray = (ideal[i] + ideal[i+1] + ideal[i+2]) / 3;
      let simGray = (sim[i] + sim[i+1] + sim[i+2]) / 3;
      let diff = Math.abs(idealGray - simGray);
      
      // Show difference as grayscale
      d[i] = d[i+1] = d[i+2] = diff;
      d[i+3] = 255;
    }
  }
  
  simCtx.putImageData(img,0,0);
}

function calculateTiming(dwellNs, delayNs, resolution) {
  // Calculate line time: (pixels per line * dwell time) + line delay
  const lineTimeNs = (resolution * dwellNs) + delayNs;
  const lineTimeMs = lineTimeNs / 1e6; // Convert to milliseconds
  
  // Calculate frame time: line time * number of lines
  const frameTimeNs = lineTimeNs * resolution;
  const frameTimeMs = frameTimeNs / 1e6; // Convert to milliseconds
  
  // Calculate frames per second
  const fps = 1000 / frameTimeMs; // Convert ms to seconds and invert
  
  return {
    lineTimeNs: lineTimeNs,
    lineTimeMs: lineTimeMs,
    frameTimeNs: frameTimeNs,
    frameTimeMs: frameTimeMs,
    fps: fps
  };
}

function updateTimingDisplay(timing) {
  document.getElementById('lineTime').textContent = `${timing.lineTimeMs.toFixed(3)} ms`;
  document.getElementById('frameTime').textContent = `${timing.frameTimeMs.toFixed(3)} ms`;
  document.getElementById('fps').textContent = `${timing.fps.toFixed(2)} fps`;
}

function updateLimitationStatus(dwellNs, bwkHz, slewRateUs) {
  const statusEl = document.getElementById('limitationStatus');
  let limitations = [];
  
  // Calculate bandwidth limitation
  const bwFreq = 1 / (2 * Math.PI * bwkHz * 1000);
  const bwTimeConstant = bwFreq;
  
  // Calculate slew rate limitation
  let slewRateText = '';
  if (slewRateUs > 0) {
    const maxSlewRate = slewRateUs * 1e6; // FS/s (full-scale per second)
    const maxChangePerDwell = maxSlewRate * dwellNs * 1e-9;
    slewRateText = `Slew rate: ${slewRateUs} FS/μs (max change per dwell: ${(maxChangePerDwell * 100).toFixed(2)}%)`;
    limitations.push(slewRateText);
  }
  
  // Bandwidth limitation
  const bwText = `Bandwidth: ${bwkHz} kHz (τ = ${(bwTimeConstant * 1e9).toFixed(1)} ns)`;
  limitations.push(bwText);
  
  if (limitations.length === 0) {
    statusEl.textContent = 'No limitations active';
  } else {
    statusEl.innerHTML = limitations.join('<br>');
  }
}


function plot(canvas,recs){
  const ctx=canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const n=recs[0].length;
  function scaleX(i){return 40+i/(n-1)*(canvas.width-50);}
  function scaleY(val){return (canvas.height-20)-val*(canvas.height-40);}
  ctx.strokeStyle="red";ctx.beginPath();
  for(let i=0;i<n;i++){let x=scaleX(i),y=scaleY(Math.min(1,recs[0][i]));if(i==0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}ctx.stroke();
  let colors=["blue","green","orange"];
  for(let k=1;k<=3;k++){ctx.strokeStyle=colors[k-1];ctx.beginPath();
    for(let i=0;i<n;i++){let x=scaleX(i),y=scaleY(Math.min(1,recs[k][i]));if(i==0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}ctx.stroke();}
}

function runSimulation() {
  const dwell=+document.getElementById("dwell").value;
  const delay=+document.getElementById("delay").value;
  const bw=+document.getElementById("bwInput").value;
  const slewRate=+document.getElementById("slewRateInput").value;
  const pat=document.getElementById("pattern").value;
  const resolution=+document.getElementById("resolution").value;
  const viewMode=document.getElementById("viewMode").value;
  
  const idealCanvas=document.getElementById("ideal");
  const simCanvas=document.getElementById("sim");
  
  // Set canvas dimensions (square resolution)
  idealCanvas.width = resolution;
  idealCanvas.height = resolution;
  simCanvas.width = resolution;
  simCanvas.height = resolution;
  
  const ideal=idealCanvas.getContext("2d");
  const sim=simCanvas.getContext("2d");
  
  drawPattern(ideal,pat,resolution,resolution);
  const recs=simulate(ideal,sim,dwell,delay,bw,slewRate);
  plot(document.getElementById("plot"),recs);
  
  // Calculate and display timing information
  const timing = calculateTiming(dwell, delay, resolution);
  updateTimingDisplay(timing);
  
  // Update limitation status
  updateLimitationStatus(dwell, bw, slewRate);
  
  // Apply view mode
  if (viewMode === "error") {
    const displacements = calculateDisplacement(dwell, delay, bw, slewRate, resolution, resolution);
    drawDisplacementHeatmap(sim, displacements, resolution, resolution);
  } else if (viewMode === "difference") {
    drawDifference(ideal, sim, resolution, resolution);
  }
}

// Convert slider position to exponential slew rate value
function sliderToSlewRate(sliderValue) {
  // Map slider (0-100) to exponential range (0.001 to 1.0)
  // Using exponential: 0.001 * (1000 ^ (sliderValue/100))
  const minSlew = 0.001;
  const maxSlew = 1.0;
  const ratio = maxSlew / minSlew;
  return minSlew * Math.pow(ratio, sliderValue / 100);
}

// Convert slew rate value to slider position
function slewRateToSlider(slewRateValue) {
  const minSlew = 0.001;
  const maxSlew = 1.0;
  const ratio = maxSlew / minSlew;
  return 100 * (Math.log(slewRateValue / minSlew) / Math.log(ratio));
}

// Convert slider position to exponential bandwidth value
function sliderToBandwidth(sliderValue) {
  // Map slider (0-100) to exponential range (1 to 1000 kHz)
  // Using exponential: 1 * (1000 ^ (sliderValue/100))
  const minBw = 1;
  const maxBw = 1000;
  const ratio = maxBw / minBw;
  return minBw * Math.pow(ratio, sliderValue / 100);
}

// Convert bandwidth value to slider position
function bandwidthToSlider(bandwidthValue) {
  const minBw = 1;
  const maxBw = 1000;
  const ratio = maxBw / minBw;
  return 100 * (Math.log(bandwidthValue / minBw) / Math.log(ratio));
}

// Update slider value displays and input boxes
function updateSliderValues() {
  const bwSliderValue = document.getElementById("bw").value;
  const slewRateSliderValue = document.getElementById("slewRate").value;
  
  // Convert exponential bandwidth slider value to actual bandwidth
  const actualBandwidth = sliderToBandwidth(bwSliderValue);
  document.getElementById("bwValue").textContent = Math.round(actualBandwidth);
  document.getElementById("bwInput").value = Math.round(actualBandwidth);
  
  // Convert exponential slider value to actual slew rate
  const actualSlewRate = sliderToSlewRate(slewRateSliderValue);
  document.getElementById("slewRateValue").textContent = actualSlewRate.toFixed(3);
  document.getElementById("slewRateInput").value = actualSlewRate.toFixed(3);
}

// Update slider from input box
function updateSliderFromInput(sliderId, inputId) {
  const inputValue = parseFloat(document.getElementById(inputId).value);
  const slider = document.getElementById(sliderId);
  
  if (sliderId === "slewRate") {
    // For slew rate, convert input value to slider position
    const sliderPos = slewRateToSlider(inputValue);
    const clampedPos = Math.max(0, Math.min(100, sliderPos));
    slider.value = clampedPos;
  } else if (sliderId === "bw") {
    // For bandwidth, convert input value to slider position
    const sliderPos = bandwidthToSlider(inputValue);
    const clampedPos = Math.max(0, Math.min(100, sliderPos));
    slider.value = clampedPos;
  } else {
    // For other controls, use linear mapping
    const min = parseFloat(slider.min);
    const max = parseFloat(slider.max);
    const clampedValue = Math.max(min, Math.min(max, inputValue));
    slider.value = clampedValue;
  }
  
  // Update display values
  updateSliderValues();
}

// Auto-simulation on any parameter change
document.getElementById("dwell").oninput = runSimulation;
document.getElementById("delay").oninput = runSimulation;

// Bandwidth slider and input
document.getElementById("bw").oninput = function() {
  updateSliderValues();
  runSimulation();
};
document.getElementById("bwInput").oninput = function() {
  updateSliderFromInput("bw", "bwInput");
  runSimulation();
};

// Slew rate slider and input
document.getElementById("slewRate").oninput = function() {
  updateSliderValues();
  runSimulation();
};
document.getElementById("slewRateInput").oninput = function() {
  updateSliderFromInput("slewRate", "slewRateInput");
  runSimulation();
};

document.getElementById("pattern").onchange = runSimulation;
document.getElementById("resolution").onchange = runSimulation;
document.getElementById("viewMode").onchange = runSimulation;

// Initialize slider values and run simulation
// Set initial values before updating displays
document.getElementById("bwInput").value = "20";
document.getElementById("slewRateInput").value = "0.05";
updateSliderValues();
runSimulation(); // Initial run with default values
</script>
</body>
</html>
