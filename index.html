<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scan Visualizer</title>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
      background: #fafafa; 
      padding: 20px; 
      margin: 0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
    }
    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }
    label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }
    input, select {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
    }
    .visualization {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .canvas-container {
      flex: 1;
      min-width: 300px;
      text-align: center;
    }
    .canvas-label {
      font-size: 14px;
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
      text-align: center;
    }
    canvas {
      border: 1px solid #ddd;
      border-radius: 8px;
      display: block;
      margin: 0 auto;
    }
    .error-info {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
    }
    .error-heatmap {
      position: relative;
    }
    .error-heatmap canvas {
      cursor: crosshair;
    }
    .plot-container {
      text-align: center;
    }
    .plot-label {
      font-size: 12px;
      color: #666;
      margin-top: 8px;
    }
    .timing-info {
      text-align: center;
      margin-top: 15px;
      font-size: 14px;
      color: #666;
    }
    .timing-info span {
      font-weight: 600;
      color: #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Scan Visualizer</h1>
    
    <div class="controls">
      <label>Dwell time (ns): <input id="dwell" type="number" value="100"></label>
      <label>Line delay (ns): <input id="delay" type="number" value="0"></label>
      <label>Bandwidth (kHz): <input id="bw" type="number" value="20"></label>
      <label>Resolution:
        <select id="resolution">
          <option value="128">128x128</option>
          <option value="256" selected>256x256</option>
          <option value="512">512x512</option>
          <option value="1024">1024x1024</option>
        </select>
      </label>
      <label>Pattern:
        <select id="pattern">
          <option value="zone" selected>Zone Plate</option>
          <option value="checker">Checkerboard</option>
          <option value="gradx">Gradient X</option>
          <option value="grady">Gradient Y</option>
          <option value="ramp2d">2D Ramp</option>
          <option value="slant">Slanted Edge</option>
          <option value="chirp">Sine Chirp</option>
          <option value="text">Text Banner</option>
          <option value="dots">Random Dots</option>
        </select>
      </label>
      <label>View:
        <select id="viewMode">
          <option value="normal">Normal</option>
          <option value="error">Displacement Heatmap</option>
          <option value="difference">Difference</option>
        </select>
      </label>
    </div>

    <div class="visualization">
      <div class="canvas-container">
        <div class="canvas-label">Ideal Pattern</div>
        <canvas id="ideal"></canvas>
      </div>
      <div class="canvas-container">
        <div class="canvas-label">Simulated Scan</div>
        <canvas id="sim"></canvas>
      </div>
    </div>

    <div class="timing-info">
      Line: <span id="lineTime">--</span> | Frame: <span id="frameTime">--</span> | FPS: <span id="fps">--</span>
    </div>

    <div class="plot-container">
      <canvas id="plot" width="600" height="200"></canvas>
      <div class="plot-label">Red = Digital command; Blue = 1st line; Green = 2nd line; Orange = Last line</div>
    </div>
  </div>

<script>
function drawPattern(ctx, type, w, h) {
  ctx.clearRect(0,0,w,h);
  if(type==="checker"){
    let cell=16;
    for(let y=0;y<h;y+=cell)
      for(let x=0;x<w;x+=cell){
        ctx.fillStyle=((x/cell+y/cell)%2)?"#000":"#fff";
        ctx.fillRect(x,y,cell,cell);
      }
  } else if(type==="gradx"){
    let g=ctx.createLinearGradient(0,0,w,0);
    g.addColorStop(0,"black"); g.addColorStop(1,"white");
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  } else if(type==="grady"){
    let g=ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,"black"); g.addColorStop(1,"white");
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  } else if(type==="ramp2d"){
    let img=ctx.createImageData(w,h),d=img.data;
    for(let y=0;y<h;y++)for(let x=0;x<w;x++){
      let val=Math.floor(((x/w)+(y/h))/2*255);
      let i=(y*w+x)*4; d[i]=d[i+1]=d[i+2]=val; d[i+3]=255;
    }
    ctx.putImageData(img,0,0);
  } else if(type==="slant"){
    ctx.fillStyle="black"; ctx.fillRect(0,0,w,h);
    ctx.strokeStyle="white"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(0,h*0.8); ctx.lineTo(w,h*0.2); ctx.stroke();
  } else if(type==="chirp"){
    let img=ctx.createImageData(w,h),d=img.data;
    for(let y=0;y<h;y++)for(let x=0;x<w;x++){
      let freq=0.5+5*(x/w);
      let val=0.5+0.5*Math.sin(2*Math.PI*freq*y/h*20);
      let g=Math.floor(val*255);
      let i=(y*w+x)*4; d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    ctx.putImageData(img,0,0);
  } else if(type==="zone"){
    let img=ctx.createImageData(w,h),d=img.data;
    for(let y=0;y<h;y++)for(let x=0;x<w;x++){
      let dx=x-w/2, dy=y-h/2;
      let r=Math.sqrt(dx*dx+dy*dy);
      let val=0.5+0.5*Math.sin(r*r/200);
      let g=Math.floor(val*255);
      let i=(y*w+x)*4; d[i]=d[i+1]=d[i+2]=g; d[i+3]=255;
    }
    ctx.putImageData(img,0,0);
  } else if(type==="text"){
    ctx.fillStyle="black"; ctx.fillRect(0,0,w,h);
    ctx.fillStyle="white"; ctx.font="30px sans-serif";
    ctx.fillText("RESCAN TEST â†’",20,h/2);
  } else if(type==="dots"){
    ctx.fillStyle="white"; ctx.fillRect(0,0,w,h);
    for(let i=0;i<2000;i++){
      ctx.fillStyle=Math.random()<0.5?"black":"gray";
      ctx.fillRect(Math.random()*w,Math.random()*h,1,1);
    }
  }
}

function simulate(srcCtx, simCtx, dwellNs, delayNs, bwkHz){
  const w=srcCtx.canvas.width, h=srcCtx.canvas.height;
  const src=srcCtx.getImageData(0,0,w,h).data;
  let dst=simCtx.createImageData(w,h), d=dst.data;
  let tau=1/(2*Math.PI*bwkHz*1000);
  function step(xOut,xCmd,dt){return xOut+(xCmd-xOut)*(1-Math.exp(-dt/tau));}
  let xOut=0; let recs=[[],[],[],[]]; // digital, line1, line2, last
  for(let j=0;j<h;j++){
    for(let i=0;i<w;i++){
      let xCmd=i/(w-1);
      xOut=step(xOut,xCmd,dwellNs*1e-9);
      let srcX=Math.floor(xOut*w), srcY=j;
      let di=(j*w+i)*4;
      if(srcX>=0&&srcX<w){let si=(srcY*w+srcX)*4; d[di]=src[si]; d[di+1]=src[si+1]; d[di+2]=src[si+2]; d[di+3]=255;}
      else{d[di]=d[di+1]=d[di+2]=0; d[di+3]=255;}
      if(j===0){recs[0].push(xCmd);recs[1].push(xOut);}
      if(j===1)recs[2].push(xOut);
      if(j===h-1)recs[3].push(xOut);
    }
    // flyback
    xOut=step(xOut,0,delayNs*1e-9);
  }
  simCtx.putImageData(dst,0,0);
  return recs;
}

function calculateDisplacement(dwellNs, delayNs, bwkHz, w, h) {
  let tau = 1/(2*Math.PI*bwkHz*1000);
  function step(xOut, xCmd, dt) { return xOut + (xCmd - xOut) * (1 - Math.exp(-dt/tau)); }
  
  let displacements = [];
  let xOut = 0;
  
  for(let j = 0; j < h; j++) {
    for(let i = 0; i < w; i++) {
      let xCmd = i / (w - 1);
      xOut = step(xOut, xCmd, dwellNs * 1e-9);
      let displacement = Math.abs(xOut - xCmd);
      displacements.push(displacement);
    }
    // flyback
    xOut = step(xOut, 0, delayNs * 1e-9);
  }
  
  return displacements;
}

function drawDisplacementHeatmap(ctx, displacements, w, h) {
  ctx.clearRect(0,0,w,h);
  let img = ctx.createImageData(w,h);
  let d = img.data;
  
  let maxDisplacement = Math.max(...displacements);
  
  for(let y=0; y<h; y++) {
    for(let x=0; x<w; x++) {
      let i = (y*w+x)*4;
      let displacement = displacements[y*w+x];
      let intensity = displacement / maxDisplacement;
      
      // Color mapping: blue (low displacement) to red (high displacement)
      if(intensity < 0.5) {
        d[i] = 0; // R
        d[i+1] = Math.floor(255 * intensity * 2); // G
        d[i+2] = 255; // B
      } else {
        d[i] = Math.floor(255 * (intensity - 0.5) * 2); // R
        d[i+1] = Math.floor(255 * (1 - intensity) * 2); // G
        d[i+2] = 0; // B
      }
      d[i+3] = 255; // A
    }
  }
  
  ctx.putImageData(img,0,0);
}

function drawDifference(idealCtx, simCtx, w, h) {
  const ideal = idealCtx.getImageData(0,0,w,h).data;
  const sim = simCtx.getImageData(0,0,w,h).data;
  
  let img = simCtx.createImageData(w,h);
  let d = img.data;
  
  for(let y=0; y<h; y++) {
    for(let x=0; x<w; x++) {
      let i = (y*w+x)*4;
      let idealGray = (ideal[i] + ideal[i+1] + ideal[i+2]) / 3;
      let simGray = (sim[i] + sim[i+1] + sim[i+2]) / 3;
      let diff = Math.abs(idealGray - simGray);
      
      // Show difference as grayscale
      d[i] = d[i+1] = d[i+2] = diff;
      d[i+3] = 255;
    }
  }
  
  simCtx.putImageData(img,0,0);
}

function calculateTiming(dwellNs, delayNs, resolution) {
  // Calculate line time: (pixels per line * dwell time) + line delay
  const lineTimeNs = (resolution * dwellNs) + delayNs;
  const lineTimeMs = lineTimeNs / 1e6; // Convert to milliseconds
  
  // Calculate frame time: line time * number of lines
  const frameTimeNs = lineTimeNs * resolution;
  const frameTimeMs = frameTimeNs / 1e6; // Convert to milliseconds
  
  // Calculate frames per second
  const fps = 1000 / frameTimeMs; // Convert ms to seconds and invert
  
  return {
    lineTimeNs: lineTimeNs,
    lineTimeMs: lineTimeMs,
    frameTimeNs: frameTimeNs,
    frameTimeMs: frameTimeMs,
    fps: fps
  };
}

function updateTimingDisplay(timing) {
  document.getElementById('lineTime').textContent = `${timing.lineTimeMs.toFixed(3)} ms`;
  document.getElementById('frameTime').textContent = `${timing.frameTimeMs.toFixed(3)} ms`;
  document.getElementById('fps').textContent = `${timing.fps.toFixed(2)} fps`;
}


function plot(canvas,recs){
  const ctx=canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const n=recs[0].length;
  function scaleX(i){return 40+i/(n-1)*(canvas.width-50);}
  function scaleY(val){return (canvas.height-20)-val*(canvas.height-40);}
  ctx.strokeStyle="red";ctx.beginPath();
  for(let i=0;i<n;i++){let x=scaleX(i),y=scaleY(Math.min(1,recs[0][i]));if(i==0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}ctx.stroke();
  let colors=["blue","green","orange"];
  for(let k=1;k<=3;k++){ctx.strokeStyle=colors[k-1];ctx.beginPath();
    for(let i=0;i<n;i++){let x=scaleX(i),y=scaleY(Math.min(1,recs[k][i]));if(i==0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}ctx.stroke();}
}

function runSimulation() {
  const dwell=+document.getElementById("dwell").value;
  const delay=+document.getElementById("delay").value;
  const bw=+document.getElementById("bw").value;
  const pat=document.getElementById("pattern").value;
  const resolution=+document.getElementById("resolution").value;
  const viewMode=document.getElementById("viewMode").value;
  
  const idealCanvas=document.getElementById("ideal");
  const simCanvas=document.getElementById("sim");
  
  // Set canvas dimensions (square resolution)
  idealCanvas.width = resolution;
  idealCanvas.height = resolution;
  simCanvas.width = resolution;
  simCanvas.height = resolution;
  
  const ideal=idealCanvas.getContext("2d");
  const sim=simCanvas.getContext("2d");
  
  drawPattern(ideal,pat,resolution,resolution);
  const recs=simulate(ideal,sim,dwell,delay,bw);
  plot(document.getElementById("plot"),recs);
  
  // Calculate and display timing information
  const timing = calculateTiming(dwell, delay, resolution);
  updateTimingDisplay(timing);
  
  // Apply view mode
  if (viewMode === "error") {
    const displacements = calculateDisplacement(dwell, delay, bw, resolution, resolution);
    drawDisplacementHeatmap(sim, displacements, resolution, resolution);
  } else if (viewMode === "difference") {
    drawDifference(ideal, sim, resolution, resolution);
  }
}

// Auto-simulation on any parameter change
document.getElementById("dwell").oninput = runSimulation;
document.getElementById("delay").oninput = runSimulation;
document.getElementById("bw").oninput = runSimulation;
document.getElementById("pattern").onchange = runSimulation;
document.getElementById("resolution").onchange = runSimulation;
document.getElementById("viewMode").onchange = runSimulation;
runSimulation(); // Initial run with default values
</script>
</body>
</html>
